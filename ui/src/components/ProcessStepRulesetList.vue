<template>
  <div class="content">
    <h1 class="title is-5">Steps</h1>
    <ol>
      <li v-for="step of stepRulesets" :key="step.sequence_number">
        <b-tooltip type="is-info is-light" multilined>
          <div :class="getStepClass(step)._class">
            {{ step.process_step.name }}
          </div>
          <template v-slot:content>
            <span class="is-size-2">ðŸ¦‰</span>
            {{ getStepClass(step)._explanation }}
          </template>
        </b-tooltip>
      </li>
    </ol>
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";

import { Move as IMove } from "@/autogenerated-interfaces/client";
import { ProcessStepRuleSet as IProcessStepRuleSet } from "@/autogenerated-interfaces/immigration";
import { RuleEvaluationResult } from "@/immigration/rules/base";
import { StepRule, StepRules } from "@/immigration/step-rules/base";
import { english as en } from "@/utils";

export default Vue.extend({
  props: {
    move: Object as PropType<IMove>,
    dates: Array as PropType<Date[]>,
    stepRulesets: Array as PropType<IProcessStepRuleSet[]>,
  },

  data() {
    return {
      rule2InputFieldName: new Map([
        [StepRule.Nationalities, "applicant nationality"],
        [StepRule.HomeCountries, "applicant home country"],
        [StepRule.Duration, "dates"],
        [StepRule.ContractLocation, "contract location"],
        [StepRule.PayrollLocation, "payroll location"],
      ]),
      rule2RuleName: new Map([
        [StepRule.Nationalities, "applicant nationality"],
        [StepRule.HomeCountries, "applicant home country"],
        [StepRule.Duration, "duration of stay"],
        [StepRule.ContractLocation, "contract location"],
        [StepRule.PayrollLocation, "payroll location"],
      ]),
    };
  },

  methods: {
    /// Return class reflecting result of applying step rules to this step.
    getStepClass(step: IProcessStepRuleSet): {
      _class: string;
      _explanation: string;
    } {
      const rules = new StepRules(step);
      const rule2result = rules.evaluate(this.move, this.dates as [Date, Date]);
      const result2rules = this._invertMap(rule2result);
      if (result2rules.has(RuleEvaluationResult.Pass)) {
        return {
          _class: "step-included",
          _explanation: `This step is required due a rule regarding ${this.enListRules(
            result2rules.get(RuleEvaluationResult.Pass) || []
          )}.`,
        };
      } else if (result2rules.has(RuleEvaluationResult.InsufficientInput)) {
        return {
          _class: "step-rule-insufficient-input",
          _explanation: `I don't know for sure whether this step will be required because you haven't entered ${this.enListFields(
            result2rules.get(RuleEvaluationResult.InsufficientInput) || []
          )}`,
        };
      } else if (result2rules.has(RuleEvaluationResult.Fail)) {
        return {
          _class: "step-excluded",
          _explanation: `This step is not required (there is a rule regarding ${this.enListRules(
            result2rules.get(RuleEvaluationResult.Fail) || []
          )} but your information didn't trigger the requirement).`,
        };
      } else {
        return {
          _class: "step-included",
          _explanation: "This step is required.",
        };
      }
    },

    enListFields(rules: StepRule[]): string {
      return en.list(
        rules.map((r) => this.rule2InputFieldName.get(r) as string)
      );
    },

    enListRules(rules: StepRule[]): string {
      return en.list(rules.map((r) => this.rule2RuleName.get(r) as string));
    },

    _invertMap(rule2result: Map<StepRule, RuleEvaluationResult>) {
      const result2rules = new Map<RuleEvaluationResult, StepRule[]>();
      for (const [rule, result] of rule2result.entries()) {
        if (!result2rules.has(result)) {
          result2rules.set(result, []);
        }
        result2rules.get(result)?.push(rule);
      }
      return result2rules;
    },
  },
});
</script>

<style scoped>
.step-excluded {
  text-decoration: line-through;
}
.step-included {
  font-weight: bold;
}
</style>