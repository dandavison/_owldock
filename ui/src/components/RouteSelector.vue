<template>
  <div class="field has-addons route-selector" style="width: 100%">
    <p class="control" style="width: 100%">
      <b-field :label="label">
        <b-autocomplete
          ref="autocomplete"
          placeholder="Select a route"
          v-model="input"
          :data="filteredProcessCandidatesForRouteSelection"
          field="route.name"
          @select="handleSelectProcessForRouteSelection"
          @blur="$emit('blur', $event)"
          :openOnFocus="true"
          dropdown-position="bottom"
          max-height="100vh"
        >
          <template slot-scope="props">
            <!-- HACK: we are deliberately trying to use two similar
            models interchangeably! -->
            <route :route="props.option.route" />
          </template>
        </b-autocomplete>
      </b-field>
    </p>
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";
import { BAutocomplete } from "buefy/src/components/autocomplete";

type BAutocompleteType = InstanceType<typeof BAutocomplete>;

// HACK: we are deliberately trying to use two similar models interchangeably!
import { ProcessRuleSet as IProcess } from "../autogenerated-interfaces/immigration";
import Route from "./Route.vue";
import { inputMatchesString } from "../utils";
import { dismissMobileKeyboardOnDropdownScroll } from "../componentUtils";

export default Vue.extend({
  components: { Route },
  props: {
    candidateProcesses: Array as PropType<IProcess[]>,
    initialProcess: {
      type: Object as PropType<IProcess | null>,
      default: null,
    },
    label: String,
  },

  data() {
    return {
      input: "",
    };
  },

  mounted() {
    dismissMobileKeyboardOnDropdownScroll(this, "autocomplete");
    if (this.initialProcess) {
      this.setSelected(this.initialProcess);
    }
  },

  computed: {
    /// Return processes with route matching input route name fragment,
    /// uniquified on route name.
    filteredProcessCandidatesForRouteSelection(): IProcess[] {
      const processes = [];
      const seen = new Set();
      for (let process of this.candidateProcesses) {
        let name = process.route.name;
        if (inputMatchesString(this.input, name)) {
          if (!seen.has(name)) {
            seen.add(name);
            processes.push(process);
          }
        }
      }
      return processes;
    },
  },

  methods: {
    setSelected(process: IProcess) {
      const autocomplete = this.$refs.autocomplete as BAutocompleteType;
      autocomplete.setSelected(process);
      this.handleSelectProcessForRouteSelection(process);
    },

    handleSelectProcessForRouteSelection(process: IProcess): void {
      // TODO: why is this complicated? Why can we not just emit the `process`
      // received as argument?
      if (!process) {
        // FIXME: why
        console.log("ERROR: process is", JSON.stringify(process));
        return;
      }
      const processes = this.candidateProcesses.filter(
        (p) => p.route.name === process.route.name
      );
      if (processes[0]) {
        if (processes.length > 1) {
          alert("TODO: multiple processes match the route and applicant data");
        }
        this.$emit("select:process", processes[0]);
      }
    },
  },
});
</script>

<style>
.route-selector .dropdown-item {
  white-space: normal !important;
}
</style>
