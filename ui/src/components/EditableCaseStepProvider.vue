<template>
  <provider-contact-selector
    v-if="providerEditable && state === State.Selecting"
    ref="providerContactSelector"
    placeholder="Select Provider"
    :giveAppearanceOfSelectingProvider="true"
    :candidateProviderContacts="candidateProviderContacts"
    @select:provider-contact="handleSelect"
    @blur="handleSelectorBlur"
  />
  <div v-else @click="handleDisplayerClick">
    <provider
      :provider="caseStep.active_contract.provider_contact.provider"
      :providerEditable="providerEditable"
      :showName="false"
    />
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";
import { BAutocomplete } from "buefy/src/components/autocomplete";

import {
  CaseStepSerializer,
  ProviderContactSerializer,
} from "../autogenerated-interfaces";
import Provider from "./Provider.vue";
import ProviderContactSelector from "./ProviderContactSelector.vue";
import { NullCaseStepContract } from "@/factories";
import { isClientContact } from "../role";

type ProviderContactSelectorType = InstanceType<typeof ProviderContactSelector>;
type BAutocompleteType = InstanceType<typeof BAutocomplete>;

enum State {
  Displaying,
  Selecting,
}

export default Vue.extend({
  props: {
    caseStep: Object as PropType<CaseStepSerializer>,
    caseStepEditable: Object,
    candidateProviderContacts: Array as PropType<ProviderContactSerializer[]>,
  },

  components: {
    Provider,
    ProviderContactSelector,
  },

  data() {
    return {
      state: State.Selecting,
      State,
    };
  },

  created() {
    this.state = this.hasProvider ? State.Displaying : State.Selecting;
  },

  computed: {
    providerEditable(): boolean {
      return isClientContact() && this.caseStepEditable.provider;
    },

    hasProvider(): boolean {
      return !!this.caseStep.active_contract?.provider_contact;
    },

    // TODO: make this a method on a CaseStep object.
    canUpdateProvider(): boolean {
      if (!isClientContact()) {
        return false;
      }
      if (this.caseStep.state.name == "FREE") {
        return true;
      }
      for (let action of this.caseStep.actions) {
        if (action.name == "client_contact_earmark_case_step") {
          return true;
        }
      }
      return false;
    },
  },

  methods: {
    handleSelect(providerContact: ProviderContactSerializer) {
      const caseStep = Object.assign({}, this.caseStep);
      if (!caseStep.active_contract) {
        caseStep.active_contract = NullCaseStepContract();
      }
      caseStep.active_contract.provider_contact = providerContact;
      this.$emit("update:case-step", caseStep);
      this.state = State.Displaying;
    },

    handleDisplayerClick() {
      if (this.canUpdateProvider) {
        this.state = State.Selecting;
        this.$nextTick(() => {
          const providerContactSelector = this.$refs
            ?.providerContactSelector as ProviderContactSelectorType;
          if (providerContactSelector) {
            const autocomplete: BAutocompleteType =
              providerContactSelector.$refs.autocomplete;
            const input: HTMLElement = autocomplete.$refs.input.$refs.input;
            input.focus();
          }
        });
      }
    },

    handleSelectorBlur(): void {
      // Hack: Changing state to Displaying will hide the autocomplete input
      // element. However, we need to give it a chance to emit its `select`
      // event, and it does not do this when it is hidden (at least, on MacOS
      // Chrome). So, we delay the state change to give time for the `select`
      // event to fire. I think that it should be possible to effect this delay
      // using $nextTick, but that didn't work in practice. There is some
      // animation in the buefy autocomplete code that may be relevant.
      setTimeout(() => (this.state = State.Displaying), 101);
    },
  },
});
</script>

<style scoped></style>
