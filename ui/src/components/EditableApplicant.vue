<template>
  <applicant-selector
    v-if="canUpdateApplicant && state === State.Selecting"
    ref="applicantSelector"
    :candidateApplicants="candidateApplicants"
    @select:applicant="handleSelect"
    @blur="handleSelectorBlur"
    class="applicant-selector"
  />
  <div v-else @click="handleDisplayerClick">
    <applicant :applicant="applicant" :applicantEditable="applicantEditable" />
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";
import { BAutocomplete } from "buefy/src/components/autocomplete";

import Applicant from "./Applicant.vue";
import ApplicantSelector from "./ApplicantSelector.vue";
import { ApplicantSerializer } from "../autogenerated-interfaces";
import { applicantIsNull } from "@/factories";
import { isClientContact } from "@/role";
import eventBus from "@/event-bus";
import http from "../http";

type ApplicantSelectorType = InstanceType<typeof ApplicantSelector>;
type BAutocompleteType = InstanceType<typeof BAutocomplete>;

enum State {
  Displaying,
  Selecting,
}

export default Vue.extend({
  props: {
    applicant: Object as PropType<ApplicantSerializer>,
    applicantEditable: Boolean,
  },

  components: {
    Applicant,
    ApplicantSelector,
  },

  data() {
    return {
      state: State.Selecting,
      candidateApplicants: [] as ApplicantSerializer[],
      State,
    };
  },

  async created() {
    this.state = this.hasApplicant ? State.Displaying : State.Selecting;
    this.candidateApplicants =
      (await http.fetchDataOrNull("/api/client-contact/applicants/")) || [];
  },

  computed: {
    hasApplicant(): boolean {
      return !applicantIsNull(this.applicant);
    },

    // TODO: make this a method
    canUpdateApplicant(): boolean {
      return isClientContact() && this.applicantEditable;
    },
  },

  methods: {
    handleSelect(applicant: ApplicantSerializer) {
      if (!applicant) {
        // FIXME: why
        console.log("ERROR: applicant is", JSON.stringify(applicant));
        return;
      }
      eventBus.$emit("update:applicant", applicant);
      // We've just selected a value, so show the rich display of the value
      // instead of the value in the selection widget.
      this.state = State.Displaying;
    },

    handleDisplayerClick() {
      if (this.canUpdateApplicant) {
        this.state = State.Selecting;
        // Focus the input element so that the dropdown opens.
        this.$nextTick(() => {
          const applicantSelector = this.$refs
            .applicantSelector as ApplicantSelectorType;
          const autocomplete: BAutocompleteType =
            applicantSelector.$refs.autocomplete;
          const input: HTMLElement = autocomplete.$refs.input.$refs.input;
          input.focus();
        });
      }
    },

    handleSelectorBlur(): void {
      // Hack: Changing state to Displaying will hide the autocomplete input
      // element. However, we need to give it a chance to emit its `select`
      // event, and it does not do this when it is hidden (at least, on MacOS
      // Chrome). So, we delay the state change to give time for the `select`
      // event to fire. I think that it should be possible to effect this delay
      // using $nextTick, but that didn't work in practice. There is some
      // animation in the buefy autocomplete code that may be relevant.
      setTimeout(() => (this.state = State.Displaying), 101);
    },
  },
});
</script>
