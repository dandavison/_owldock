// A table that can be used to display a list of cases, or a single case as a //
header for a case detail view.
<template>
  <b-table
    ref="table"
    :data="rows"
    :paginated="paginated"
    :per-page="10"
    :focusable="focusable"
    :selected.sync="selectedRowProxy"
    @dblclick="(row) => $emit('dblclick', row)"
    hoverable
  >
    <b-table-column label="Applicant" v-slot="props">
      <editable-applicant
        :applicant="props.row.applicant"
        :applicantEditable="
          casesEditable &&
          casesEditable[props.index] &&
          casesEditable[props.index].applicant
        "
      />
    </b-table-column>

    <b-table-column label="Host Country" v-slot="props">
      <editable-country
        :country="
          props.row.process &&
          props.row.process.route &&
          props.row.process.route.host_country
        "
        :countryEditable="
          casesEditable &&
          casesEditable[props.index] &&
          casesEditable[props.index].country
        "
      />
    </b-table-column>

    <b-table-column label="Dates" v-slot="props">
      <editable-date-range
        :dateRange="[props.row.target_entry_date, props.row.target_exit_date]"
        :dateRangeEditable="
          casesEditable &&
          casesEditable[props.index] &&
          casesEditable[props.index].dateRange
        "
      />
    </b-table-column>

    <b-table-column label="Route" v-if="showProcess" v-slot="props">
      <editable-route
        :route="props.row.process.route"
        :routeEditable="
          casesEditable &&
          casesEditable[props.index] &&
          casesEditable[props.index].route
        "
      />
    </b-table-column>

    <b-table-column label="Provider" v-if="showProviders" v-slot="props">
      <editable-provider
        :providers="getProviders(props.row)"
        :process="props.row.process"
        :providerEditable="
          casesEditable &&
          casesEditable[props.index] &&
          casesEditable[props.index].provider
        "
      />
    </b-table-column>
  </b-table>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";

import { CaseSerializer, ProviderSerializer } from "@/autogenerated-interfaces";
import EditableApplicant from "../components/EditableApplicant.vue";
import EditableCountry from "../components/EditableCountry.vue";
import EditableDateRange from "../components/EditableDateRange.vue";
import EditableRoute from "../components/EditableRoute.vue";
import EditableProvider from "../components/EditableProvider.vue";

export default Vue.extend({
  props: {
    rows: Array as PropType<CaseSerializer[]>,
    casesEditable: Array,
    selected: Object,
    // TODO: focusable must always be true when using `selected`?
    focusable: Boolean,
    paginated: {
      type: Boolean,
      default: false,
    },
    showProviders: {
      type: Boolean,
      default: false,
    },
    showProcess: {
      type: Boolean,
      default: true,
    },
  },
  components: {
    EditableCountry,
    EditableDateRange,
    EditableApplicant,
    EditableProvider,
    EditableRoute,
  },

  data() {
    return {
      selectedRowProxy: {},
    };
  },

  watch: {
    selectedRowProxy: function (row) {
      // This is slightly convoluted. This component is standing downstream of a
      // view, and upstream of b-table. But the b-table selected row feature
      // doesn't really seem to be designed for that: it requires the use of
      // :selected.sync=x, therefore `x` must be owned data, not the prop that
      // the upstream view has passed in. So, this intermediate component owns
      // some data (this.selectedRowProxy), and that data is updated by the
      // required selected.sync with the downstream b-table, and this watcher
      // notifies the upstream view when the selected row changes.
      this.$emit("update:selected", row);
    },
  },

  methods: {
    getProviders(case_: CaseSerializer): ProviderSerializer[] {
      const providers = [];
      const seen = new Set<string>();
      for (let step of case_.steps) {
        if (!step.active_contract) {
          continue;
        }
        let provider = step.active_contract.provider_contact.provider;
        if (provider.uuid && !seen.has(provider.uuid)) {
          providers.push(provider);
          seen.add(provider.uuid);
        }
      }
      return providers.sort((p1, p2) => (p1.name <= p2.name ? 0 : 1));
    },
  },
});
</script>

<style>
.table tr.is-selected {
  background-color: #eeeeee !important;
  color: currentColor;
}
</style>
