// A table that can be used to display a list of cases, or a single case as a
// header for a case detail view.
<template>
  <b-table
    ref="table"
    :data="rows"
    :paginated="paginated"
    :per-page="10"
    :focusable="focusable"
    :selected.sync="selectedRowProxy"
    @dblclick="(row) => $emit('dblclick', row)"
    hoverable
  >
    <b-table-column label="Applicant" v-slot="props">
      <applicant :applicant="props.row.applicant"></applicant>
    </b-table-column>

    <b-table-column label="Host Country" v-slot="props">
      <country
        v-if="!countryIsNull(props.row.process.route.host_country)"
        :country="props.row.process.route.host_country"
      >
      </country>
    </b-table-column>

    <b-table-column label="Entry Date" v-slot="props">
      {{ props.row.target_entry_date }}
    </b-table-column>

    <b-table-column label="Exit Date" v-slot="props">
      {{ props.row.target_exit_date }}
    </b-table-column>

    <b-table-column label="Provider" v-if="showProviders" v-slot="props">
      <provider
        v-for="provider in getProviders(props.row)"
        :key="provider.uuid"
        :provider="provider"
        :showName="false"
      >
      </provider>
    </b-table-column>

    <b-table-column label="Route" v-if="showProcess" v-slot="props">
      <process :case_="props.row" :showSteps="false"> </process>
    </b-table-column>
  </b-table>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";

import { CaseSerializer, ProviderSerializer } from "@/autogenerated-interfaces";
import Applicant from "../components/Applicant.vue";
import Country from "../components/Country.vue";
import Process from "../components/Process.vue";
import Provider from "../components/Provider.vue";
import { countryIsNull } from "../factories";

export default Vue.extend({
  props: {
    rows: Array as PropType<CaseSerializer[]>,
    selected: Object,
    // TODO: focusable must always be true when using `selected`?
    focusable: Boolean,
    paginated: {
      type: Boolean,
      default: false,
    },
    showProviders: {
      type: Boolean,
      default: false,
    },
    showProcess: {
      type: Boolean,
      default: false,
    },
  },
  components: { Applicant, Country, Process, Provider },

  data() {
    return {
      countryIsNull,
      selectedRowProxy: {},
    };
  },

  watch: {
    selectedRowProxy: function (row) {
      // This is slightly convoluted. This component is standing downstream of a
      // view, and upstream of b-table. But the b-table selected row feature
      // doesn't really seem to be designed for that: it requires the use of
      // :selected.sync=x, therefore `x` must be owned data, not the prop that
      // the upstream view has passed in. So, this intermediate component owns
      // some data (this.selectedRowProxy), and that data is updated by the
      // required selected.sync with the downstream b-table, and this watcher
      // notifies the upstream view when the selected row changes.
      this.$emit("update:selected", row);
    },
  },

  methods: {
    getProviders(case_: CaseSerializer): ProviderSerializer[] {
      const providers = [];
      const seen = new Set<string>();
      for (let step of case_.steps) {
        if (!step.active_contract) {
          continue;
        }
        let provider = step.active_contract.provider_contact.provider;
        if (provider.uuid && !seen.has(provider.uuid)) {
          providers.push(provider);
          seen.add(provider.uuid);
        }
      }
      return providers.sort((p1, p2) => (p1.name <= p2.name ? 0 : 1));
    },
  },
});
</script>

<style>
.table tr.is-selected {
  background-color: #eeeeee !important;
  color: currentColor;
}
</style>
