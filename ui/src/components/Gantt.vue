<template>
  <div class="content section x-scrollable">
    <svg
      v-show="tasks.length > 0"
      v-bind="svgProps"
      id="gantt"
      @click="handleSvgClick"
    />
    <div
      v-show="tasks.length === 0"
      class="section mb-6"
      style="text-align: center"
    >
      This process has no steps yet.
    </div>
    <gantt-editor
      :selectedTask="selectedTask"
      :tasks="tasks"
      :process="process"
    />
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";

import * as d3Array from "d3-array";
import * as d3Axis from "d3-axis";
import * as d3Scale from "d3-scale";
import * as d3Selection from "d3-selection";
// import { Selection } from "d3-selection";
const d3 = Object.assign({}, d3Array, d3Axis, d3Scale, d3Selection);

import GanttEditor from "./GanttEditor.vue";
import { ProcessRuleSet } from "@/pydantic-autogenerated-interfaces";
import eventBus from "@/event-bus";

interface Selection {
  enter: Selection;
  append: (x: string) => Selection;
  remove: () => Selection;
  size: () => number;
  attr: (k: string, v: unknown) => Selection;
  call: (f: any) => Selection;
  select: (s: string) => Selection;
}

export interface Task {
  id: number;
  title: string;
  duration: number[]; // TODO: [number, number]
  time: [number, number];
  text: string;
  progress: number;
  dependsOn: number[];
  [key: string]: number | string | number[] | [number, number];
}

function taskTimeDisplay(t: Task): string {
  if (t.time[1] > t.time[0]) {
    return `Day ${t.time[0] + 1} - ${t.time[1]}`;
  } else {
    return `Day ${t.time[0] + 1}`;
  }
}

interface Box {
  left: number;
  top: number;
  right: number;
  bottom: number;
}

export default Vue.extend({
  components: { GanttEditor },
  props: {
    tasks: Array as PropType<Task[]>,
    process: Object as PropType<ProcessRuleSet>,
    width: Number,
  },

  data() {
    return {
      taskRect: { height: 50, gap: 10 },
      margin: { left: 20, top: 40, right: 270, bottom: 20 } as Box,
      selectedTask: null as Task | null,
      bars: d3.select(),
    };
  },

  watch: {
    tasks: function () {
      this.updateGantt();
    },
  },

  mounted() {
    this.updateGantt();
    eventBus.$on(
      "update:selected-task",
      (task: Task | null) => (this.selectedTask = task)
    );
  },

  updated() {
    this.updateGantt();
  },

  methods: {
    updateGantt() {
      const [x, y] = [this.x, this.y];
      const svg = d3.select("#gantt");

      // HACK
      svg.selectAll("g").remove();

      // An SVG g container for each row
      this.bars = svg
        .selectAll("g")
        .data(this.tasks, (d: Task) => (d ? d.id : svg.id))
        .join(
          "g"
          // (enter: Selection) => {
          //   console.log("enter:", enter.size());
          //   return enter.append("g");
          // },
          // (update: Selection) => {
          //   console.log("update:", update.size());
          //   return update;
          // },
          // (exit: Selection) => {
          //   console.log("exit:", exit.size());
          //   return exit.remove();
          // }
        )
        .attr(
          "transform",
          (_: Task, i: number) => `translate(0,${y(i as any)})`
        );

      // A rect in each row, representing a step, extending horizontally from
      // start to end time.
      this.bars
        .append("rect")
        .attr("class", "task-rect")
        .attr("transform", (d: Task) => `translate(${x(d.time[0])},0)`)
        .attr("width", (d: Task) => x(d.time[1]) - x(d.time[0]))
        .attr("height", y.bandwidth() - this.taskRect.gap)
        .attr("rx", 5)
        .attr("ry", 5);

      // Task title inside each rect, upper left
      this.bars
        .append("text")
        .attr("class", "task-title")
        .attr("transform", (d: Task) => `translate(${x(d.time[0])},0)`)
        .attr("x", 5)
        .attr("y", 0.3 * (y.bandwidth() - this.taskRect.gap))
        .attr("dy", "0.35em")
        .text((d: Task) =>
          d.title.toLowerCase() === "entry" ? `ðŸ›‚ ${d.title}` : d.title
        );

      // Task text inside each rect, lower left
      this.bars
        .append("text")
        .attr("class", "task-text")
        .attr("transform", (d: Task) => `translate(${x(d.time[0])},0)`)
        .attr("x", 5)
        .attr("y", 0.7 * (y.bandwidth() - this.taskRect.gap))
        .attr("dy", "0.35em")
        .text(taskTimeDisplay);

      // Click on a bar to select
      this.bars.on("click", (event: Event, d: Task) => {
        this.selectedTask = d;
        this.bars.attr("class", (e: Task) =>
          e.id == d.id ? "" : "unselected"
        );
        event.stopPropagation();
      });

      this.upsertAxis(svg);
    },

    handleSvgClick() {
      this.selectedTask = null;
      (this.bars as Selection).attr("class", "");
    },

    upsertAxis(svg: Selection) {
      // https://davidbanks.co.nz/post/transition-d3-axes
      // Horizontal time axis
      const axis = d3.select("#x-axis");
      if (axis.empty()) {
        svg
          .append("g")
          .call(d3.axisTop(this.x))
          .attr("id", "x-axis")
          .attr(
            "transform",
            `translate(0,${this.y.range()[0] - this.margin.top / 2})`
          );
      } else {
        axis.call(d3.axisTop(this.x));
      }
    },
  },

  computed: {
    x(): d3Scale.ScaleLinear<number, number, never> {
      const margin = this.margin as Box;
      return d3
        .scaleLinear()
        .domain([0, Math.max(...this.tasks.map((d) => d.time[1] || 0))])
        .range([margin.left, this.width - margin.right]);
    },

    y(): d3Scale.ScaleBand<string> {
      const margin = this.margin as Box;
      return d3
        .scaleBand()
        .domain(d3.range(this.tasks.length) as any)
        .range([
          margin.top,
          margin.top + this.taskRect.height * this.tasks.length,
        ]);
    },

    svgProps(): Record<string, number | string> {
      const margin = this.margin as Box;
      return {
        width: this.width,
        height: this.y.range()[1] + margin.bottom,
        "font-family": "sans-serif",
        "font-size": "10",
        "text-anchor": "start",
      };
    },
  },
});
</script>

<style>
.task-rect {
  fill: #f3f3f3;
  stroke: #cccccc;
  stroke-width: 1;
}
g.unselected {
  opacity: 0.4;
}
.task-title {
  font-weight: bold;
  font-size: 1.3em;
}
.task-progress {
  fill: red;
  stroke: red;
  stroke-width: 1;
}
.x-scrollable {
  overflow-x: scroll;
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}
.x-scrollable::-webkit-scrollbar {
  display: none;
}
</style>
