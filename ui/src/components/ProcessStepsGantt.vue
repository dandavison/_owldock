<template>
  <!-- The role of :process="process" this component is to convert ProcessStepRuleSets (an
  Owldock-domain specific data model) into Tasks (a generic data model used by
  the Gantt chart), and to contain the Gantt chart itself as a child.   -->
  <div class="content section m-5">
    <gantt :tasks="tasks" :process="process" :width="width" />
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";

import Gantt, { Task } from "./Gantt.vue";
import {
  ProcessRuleSet,
  ProcessStep,
} from "@/pydantic-autogenerated-interfaces";
import eventBus from "@/event-bus";

export default Vue.extend({
  components: { Gantt },
  props: { process: Object as PropType<ProcessRuleSet>, width: Number },

  data() {
    return {
      tasks: makeTasks(this.process),
    };
  },

  watch: {
    process(value: ProcessRuleSet) {
      this.tasks = makeTasks(value);
    },
  },

  mounted() {
    eventBus.$on("update:task-duration", this.updateTaskDuration);
    eventBus.$on("update:task-depends-on", this.updateTaskDependsOn);
    eventBus.$on("remove:task", this.removeTask);
    eventBus.$on("add:step", this.addStep);
  },

  methods: {
    updateTaskDuration(id: number, idx: number, value: string): void {
      if (!value) {
        return;
      }
      for (const task of this.tasks) {
        if (task.id === id) {
          task.duration[idx] = parseInt(value);
          this.tasks = computeTaskTimes(this.tasks);
          return;
        }
      }
      console.warn(`updateTaskDuration: no task has id=${id}`);
    },

    updateTaskDependsOn(id: number, value: number[]): void {
      for (const task of this.tasks) {
        if (task.id === id) {
          task.dependsOn = value;
          this.tasks = computeTaskTimes(this.tasks);
          return;
        }
      }
      console.warn(`updateTaskDependsOn: no task has id=${id}`);
    },

    removeTask(id: number) {
      let i = 0;
      for (const task of this.tasks) {
        if (task.id === id) {
          this.tasks.splice(i, 1);
          this.tasks = computeTaskTimes(this.tasks);
          return;
        }
        i++;
      }
      console.warn(`removeTask: no task has id=${id}`);
    },

    addStep(step: ProcessStep): void {
      this.tasks.push(makeTask(step));
      this.tasks = computeTaskTimes(this.tasks);
    },
  },
});

export function makeTasks(process: ProcessRuleSet): Task[] {
  return computeTaskTimes(
    process.step_rulesets.map((sr) => makeTask(sr.process_step))
  );
}

export function makeTask(step: ProcessStep): Task {
  return {
    id: step.id,
    title: step.name,
    text: "",
    progress: 0,
    duration: [...step.step_duration_range],
    time: [-1, -1],
    dependsOn: [...step.depends_on_ids],
  };
}

/// Input: A tree of Steps (i.e. a Step[] array, each element of which has a
/// Step[] array containing steps that it depends on).
///
/// Output: the same Step[] array, but with non-null startTime
function computeTaskTimes(tasks: Task[]): Task[] {
  const id2task = new Map(tasks.map((t) => [t.id, t]));
  for (const task of tasks) {
    task.time = _computeTaskTime(task, id2task);
  }
  return tasks.sort((a: Task, b: Task) => {
    const startCmp = a.time[0] - b.time[0];
    const endCmp = a.time[1] - b.time[1];
    return startCmp != 0 ? startCmp : endCmp;
  });
}

function _computeTaskTime(
  task: Task,
  id2task: Map<number, Task>
): [number, number] {
  // A step with no dependencies starts immediately. (Note that a step may
  // have no dependencies in the context of this process, yet be dependent on
  // other steps in the context of another process.
  const dependencies = task.dependsOn
    .map((id) => id2task.get(id) as Task)
    .filter(Boolean);
  if (dependencies.length === 0) {
    return [0.0, (task.duration[0] || 0) as number];
  }
  // Otherwise, it starts when the last of its dependencies finishes, i.e. at
  // the greatest of the lower-bound times imposed by its dependencies.
  const lowerBounds: number[] = [];
  for (const dependency of dependencies) {
    if (dependency.time[0] < 0) {
      dependency.time = _computeTaskTime(dependency, id2task);
    }
    lowerBounds.push(dependency.time[0] + (dependency.duration[0] as number));
  }
  const start = Math.max(...lowerBounds);
  return [start, start + (task.duration[0] as number)];
}
</script>
