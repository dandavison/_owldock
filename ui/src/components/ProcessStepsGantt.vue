<template>
  <!-- The role of :process="process" this component is to convert ProcessStepRuleSets (an
  Owldock-domain specific data model) into Tasks (a generic data model used by
  the Gantt chart), and to contain the Gantt chart itself as a child.   -->
  <div class="content section m-5">
    <gantt :tasks="tasks" :process="process" :width="width" />
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";
import { NotificationProgrammatic as Notification } from "buefy";

import Gantt, { Task } from "./Gantt.vue";
import {
  ProcessRuleSet,
  ProcessStep,
} from "@/pydantic-autogenerated-interfaces";
import { ProcessStepType } from "@/constants";
import eventBus from "@/event-bus";
import { CircularDependencyError } from "@/error";

export default Vue.extend({
  components: { Gantt },
  props: { process: Object as PropType<ProcessRuleSet>, width: Number },

  data() {
    return {
      tasks: makeTasks(this.process),
    };
  },

  watch: {
    process(value: ProcessRuleSet) {
      this.tasks = makeTasks(value);
    },
  },

  mounted() {
    eventBus.$on("update:task-duration", this.updateTaskDuration);
    eventBus.$on("update:task-depends-on", this.updateTaskDependsOn);
    eventBus.$on("remove:task", this.removeTask);
    eventBus.$on("add:step", this.addStep);
  },

  methods: {
    updateTaskDuration(id: number, idx: number, value: string): void {
      if (!value) {
        return;
      }
      const tasks: Task[] | null = this.copyTasksWithoutTimes();
      for (const task of tasks) {
        if (task.id === id) {
          task.duration[idx] = parseInt(value);
          if (computeTaskTimes(tasks)) {
            this.tasks = tasks;
          }
          return;
        }
      }
      console.warn(`updateTaskDuration: no task has id=${id}`);
    },

    updateTaskDependsOn(id: number, value: number[]): void {
      const tasks: Task[] | null = this.copyTasksWithoutTimes();
      for (const task of tasks) {
        if (task.id === id) {
          task.dependsOn = value;
          if (computeTaskTimes(tasks)) {
            this.tasks = tasks;
          }
          return;
        }
      }
      console.warn(`updateTaskDependsOn: no task has id=${id}`);
    },

    removeTask(id: number) {
      let tasks: Task[] | null = this.copyTasksWithoutTimes();
      let i = 0;
      for (const task of tasks) {
        if (task.id === id) {
          tasks.splice(i, 1);
          tasks = pruneTasks(tasks);
          if (computeTaskTimes(tasks)) {
            this.tasks = tasks;
          }
          eventBus.$emit("update:selected-task", null);
          return;
        }
        i++;
      }
      console.warn(`removeTask: no task has id=${id}`);
    },

    addStep(step: ProcessStep): void {
      const tasks: Task[] | null = this.copyTasksWithoutTimes();
      tasks.push(makeTask(step));
      if (computeTaskTimes(tasks)) {
        this.tasks = tasks;
      }
    },

    copyTasksWithoutTimes(): Task[] {
      return this.tasks.map((t) => Object.assign({}, t, { time: [-1, -1] }));
    },
  },
});

export function makeTasks(process: ProcessRuleSet): Task[] {
  return (
    computeTaskTimes(
      process.step_rulesets.map((sr) => makeTask(sr.process_step))
    ) || []
  );
}

export function makeTask(step: ProcessStep): Task {
  var title;
  if (step.host_country) {
    title = `${step.host_country.unicode_flag} ${step.name}`;
  } else {
    title = `üåç ${step.name}`;
  }
  return {
    id: step.id,
    type: step.type,
    title,
    text: "",
    progress: 0,
    duration: [...step.step_duration_range],
    time: [-1, -1],
    dependsOn: [...step.depends_on_ids],
  };
}

/// Definition: Task B is a "depender" of task A if task B depends on task A.
/// The definition of "depends on" here is transitive; i.e. if C depends on B
/// and B depends on A then C is a depender of A.

/// Definition: task B is a "direct depender" of task A if B depends directly on
/// A. I.e. if C depends on B and B depends on A (and those are the only
/// relationships) then C is not a direct depender of A.

/// Delete every task that is (a) Ancillary and (b) all its dependers are
/// Ancillary.
function pruneTasks(tasks: Task[]): Task[] {
  for (;;) {
    let pruned = _pruneTasksSinglePass(tasks);
    if (pruned.length === tasks.length) {
      return tasks;
    }
    tasks = pruned;
  }
}

/// Perform a single pass over tasks, deleting every Ancillary task with no
/// direct depender. Return pruned tasks.
function _pruneTasksSinglePass(tasks: Task[]): Task[] {
  const task2dependers = new Map<Task, number>(tasks.map((t) => [t, 0]));
  const id2task = new Map(tasks.map((t) => [t.id, t]));
  for (const task of tasks) {
    for (const dependeeId of task.dependsOn) {
      let dependee = id2task.get(dependeeId);
      if (!dependee) {
        // TODO: I think we are currently including all dependencies of global
        // steps in the payload, i.e. including some which are irrelevant to the
        // current country.
        continue;
      }
      let n = task2dependers.get(dependee) as number;
      task2dependers.set(dependee, n + 1);
    }
  }
  let toDelete = new Set<number>();
  for (const [task, n] of task2dependers.entries()) {
    if (task.type === ProcessStepType.Ancillary && n === 0) {
      toDelete.add(task.id);
    }
  }
  return tasks.filter((t) => !toDelete.has(t.id));
}

/// Input: A tree of Tasks (i.e. a Task[] array, each element of which has a
/// Task[] array containing tasks that it depends on).
///
/// Output: the same Task[] array, but with non-null startTime

/// Note: the function mutates the input data structure, and also returns it.
function computeTaskTimes(tasks: Task[]): Task[] | null {
  const id2task = new Map(tasks.map((t) => [t.id, t]));
  for (const task of tasks) {
    try {
      task.time = _computeTaskTime(task, id2task, new Set());
    } catch (e) {
      if (e instanceof CircularDependencyError) {
        console.error(e.message);
        Notification.open({
          message: e.message,
          type: "is-danger",
          hasIcon: true,
          position: "is-bottom-left",
          indefinite: true,
        });
        return null;
      } else {
        throw e;
      }
    }
  }
  return tasks.sort((a: Task, b: Task) => {
    const startCmp = a.time[0] - b.time[0];
    const endCmp = a.time[1] - b.time[1];
    return startCmp != 0 ? startCmp : endCmp;
  });
}

function _computeTaskTime(
  task: Task,
  id2task: Map<number, Task>,
  seen: Set<number>
): [number, number] {
  if (seen.has(task.id)) {
    const cycle = Array.from(seen)
      .map((id) => `<li>${id2task.get(id)?.title}</li>`)
      .join("");
    throw new CircularDependencyError(
      `Circular dependency chain:<br><ul>` + cycle + "</ul>"
    );
  }
  seen.add(task.id);
  // A step with no dependencies starts immediately. (Note that a step may
  // have no dependencies in the context of this process, yet be dependent on
  // other steps in the context of another process.
  const dependencies = task.dependsOn
    .map((id) => id2task.get(id) as Task)
    .filter(Boolean);
  if (dependencies.length === 0) {
    return [0.0, (task.duration[0] || 0) as number];
  }
  // Otherwise, it starts when the last of its dependencies finishes, i.e. at
  // the greatest of the lower-bound times imposed by its dependencies.
  const lowerBounds: number[] = [];
  for (const dependency of dependencies) {
    if (dependency.time[0] < 0) {
      dependency.time = _computeTaskTime(dependency, id2task, seen);
    }
    lowerBounds.push(dependency.time[0] + (dependency.duration[0] as number));
  }
  const start = Math.max(...lowerBounds);
  return [start, start + (task.duration[0] as number)];
}
</script>
