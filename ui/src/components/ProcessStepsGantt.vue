<template>
  <gantt :tasks="tasks" :width="width" />
</template>

<script lang="ts">
import Vue, { PropType } from "vue";

import Gantt, { Task } from "./Gantt.vue";
import { ProcessStepRuleSet } from "@/pydantic-autogenerated-interfaces";

interface ProcessStepRuleSetWithTime extends ProcessStepRuleSet {
  time: [number, number];
}

export default Vue.extend({
  components: { Gantt },
  props: { steps: Array as PropType<ProcessStepRuleSet[]>, width: Number },

  computed: {
    tasks(): Task[] {
      const steps = this.steps.map((s) =>
        Object.assign({ time: [-1, -1] as [number, number] }, s)
      ) as ProcessStepRuleSetWithTime[];
      computeStartTimes(steps);
      const tasks = steps.map((s) => ({
        title: s.process_step.name,
        time: s.time,
      })) as Task[];
      tasks.sort((a: Task, b: Task) => a.time[0] - b.time[0]);
      return tasks;
    },
  },
});

/// Input: A tree of Steps (i.e. a Step[] array, each element of which has a
/// Step[] array containing steps that it depends on).
///
/// Output: the same Step[] array, but with non-null startTime
function computeStartTimes(steps: ProcessStepRuleSetWithTime[]): void {
  const id2step = new Map(steps.map((s) => [s.process_step.id, s]));
  for (const step of steps) {
    step.time = _computeStartTime(step, id2step);
  }
}

function _computeStartTime(
  step: ProcessStepRuleSetWithTime,
  id2step: Map<number, ProcessStepRuleSetWithTime>
): [number, number] {
  if (step.process_step.depends_on_.length === 0) {
    // A step with no dependencies starts immediately.
    return [0.0, (step.process_step.step_duration_range[0] || 0) as number];
  } else {
    // Otherwise, it starts when the last of its dependencies finishes, i.e. at
    // the greatest of the lower-bound times imposed by its dependencies.
    const lowerBounds: number[] = [];
    const dependencies = step.process_step.depends_on_
      .map((s) => id2step.get(s.id) as ProcessStepRuleSetWithTime)
      .filter(Boolean);
    for (const dependency of dependencies) {
      if (dependency.time === [-1, -1]) {
        dependency.time = _computeStartTime(dependency, id2step);
      }
      lowerBounds.push(
        dependency.time[0] +
          (dependency.process_step.step_duration_range[0] as number)
      );
    }
    const start = Math.max(...lowerBounds);
    return [
      start,
      start + (step.process_step.step_duration_range[0] as number),
    ];
  }
}
</script>
