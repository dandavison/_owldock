<template>
  <fieldset
    v-if="canUpdate && state === State.Selecting"
    :disabled="editingSpec.disabled"
  >
    <route-selector
      ref="selector"
      :candidateProcesses="candidateProcesses"
      @select:process="handleSelect"
      @blur="editableComponentProxy.handleSelectorBlur()"
      class="route-selector"
    />
  </fieldset>
  <div v-else @click="editableComponentProxy.handleDisplayerClick()">
    <route :route="route" :editable="editingSpec.editable" />
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";

import Route from "./Route.vue";
import RouteSelector from "./RouteSelector.vue";
import {
  EditableComponentProxy,
  EditingSpec,
  State,
} from "../editable-component";
import {
  ProcessRuleSet as IProcess,
  Route as IRoute,
} from "../autogenerated-interfaces/immigration";
import { NullRoute, routeIsNull } from "@/factories";
import { isAdmin, isClientContact } from "@/role";
import eventBus from "@/event-bus";

type RouteSelectorType = InstanceType<typeof RouteSelector>;

export default Vue.extend({
  props: {
    route: {
      type: Object as PropType<IRoute>,
      default: NullRoute,
    },
    editingSpec: {
      type: Object as PropType<EditingSpec>,
      default: () => ({ editable: true, disabled: false }),
    },
    // TODO: HACK: The update:candidate-processes should be mutating the
    // upstream data?
    initialCandidateProcesses: {
      type: Array as PropType<IProcess[]>,
      default: () => [],
    },
  },

  components: {
    Route,
    RouteSelector,
  },

  data() {
    return {
      state: State.Selecting,
      State,
      candidateProcesses: [...this.initialCandidateProcesses],
    };
  },

  watch: {
    // TODO: HACK: See comment above
    initialCandidateProcesses(value: IProcess[]) {
      this.candidateProcesses = value;
    },

    route() {
      this.setRouteAsSelected();
    },
  },

  created() {
    this.state = this.hasDisplayable ? State.Displaying : State.Selecting;
    eventBus.$on(
      "update:candidate-processes",
      (processes: IProcess[]) => (this.candidateProcesses = processes)
    );
  },

  computed: {
    editableComponentProxy(): EditableComponentProxy {
      return new EditableComponentProxy(this);
    },

    hasDisplayable(): boolean {
      return !routeIsNull(this.route);
    },

    // TODO: make this a method
    canUpdate(): boolean {
      return (isAdmin() || isClientContact()) && this.editingSpec.editable;
    },
  },

  methods: {
    setRouteAsSelected() {
      if (!routeIsNull(this.route)) {
        for (const process of this.candidateProcesses) {
          if (process.route.name === this.route.name) {
            const selector = this.$refs.selector as RouteSelectorType;
            if (selector) {
              selector.setSelected(process);
              this.handleSelect(process);
            }
          }
        }
      }
    },

    handleSelect(process: IProcess) {
      if (process) {
        eventBus.$emit("update:process", process);
        this.state = State.Displaying;
      } else {
        console.warn("Null process in handleSelect");
      }
    },
  },
});
</script>
