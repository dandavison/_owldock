<template>
  <provider-contact-selector
    v-if="providerEditable && state === State.Selecting"
    ref="providerContactSelector"
    :candidateProviderContacts="candidateProviderContacts"
    :giveAppearanceOfSelectingProvider="true"
    @select:provider-contact="handleSelect"
    @blur="handleSelectorBlur"
    class="provider-contact-selector"
  />
  <div v-else @click="handleDisplayerClick">
    <provider
      v-for="provider in providers"
      :key="provider.uuid"
      :provider="provider"
      :providerEditable="providerEditable"
      :showName="false"
    />
  </div>
</template>

<script lang="ts">
import Vue, { PropType } from "vue";
import { BAutocomplete } from "buefy/src/components/autocomplete";

import Provider from "./Provider.vue";
import ProviderContactSelector from "./ProviderContactSelector.vue";
import {
  ProviderSerializer,
  ProviderContactSerializer,
  ProcessSerializer,
  CaseStepSerializer,
} from "../autogenerated-interfaces";
import { isClientContact } from "@/role";
import { processIsNull } from "@/factories";
import http from "../http";
import eventBus from "@/event-bus";

type ProviderContactSelectorType = InstanceType<typeof ProviderContactSelector>;
type BAutocompleteType = InstanceType<typeof BAutocomplete>;

enum State {
  Displaying,
  Selecting,
}

export default Vue.extend({
  props: {
    providerEditable: Boolean,
    // TODO: `process` and `steps` are not independent: if the steps all belong
    // to the same process then that is the definition of `process`; otherwise,
    // `process` is not defined. So, this component should probably take in
    // `steps` alone, and compute `process`, if it can be computed.
    process: Object as PropType<ProcessSerializer>,
    steps: Array as PropType<CaseStepSerializer[]>,
  },

  components: {
    Provider,
    ProviderContactSelector,
  },

  data() {
    return {
      state: State.Selecting,
      State,
      candidateProviderContacts: [] as ProviderContactSerializer[],
    };
  },

  created() {
    this.state = this.hasProvider ? State.Displaying : State.Selecting;
    if (!processIsNull(this.process)) {
      this.fetchProviderContacts(this.process);
    }
  },

  computed: {
    providers(): ProviderSerializer[] {
      const providers = [];
      const seen = new Set<string>();
      for (let step of this.steps) {
        if (!step.active_contract) {
          continue;
        }
        let provider = step.active_contract.provider_contact.provider;
        if (provider.uuid && !seen.has(provider.uuid)) {
          providers.push(provider);
          seen.add(provider.uuid);
        }
      }
      return providers.sort((p1, p2) => (p1.name <= p2.name ? 0 : 1));
    },

    hasProvider(): boolean {
      return this.providers.length > 0;
    },

    // TODO: make this a method
    canUpdateProvider(): boolean {
      return isClientContact();
    },
  },

  watch: {
    process: function (value: ProcessSerializer): void {
      this.fetchProviderContacts(value);
    },
  },

  methods: {
    async fetchProviderContacts(process_: ProcessSerializer) {
      if (!process_.uuid) {
        // TODO: why?
        return;
      }
      const url = `/api/client-contact/list-primary-provider-contacts/?process_uuid=${process_.uuid}`;
      this.candidateProviderContacts = (await http.fetchDataOrNull(url)) || [];
    },

    handleSelect(providerContact: ProviderContactSerializer) {
      if (!providerContact) {
        // FIXME: why
        console.error(
          "ERROR: providerContact is",
          JSON.stringify(providerContact)
        );
        return;
      }
      eventBus.$emit("update:provider-contact", providerContact);
      this.state = State.Displaying;
    },

    handleDisplayerClick() {
      if (this.canUpdateProvider) {
        this.state = State.Selecting;
        this.$nextTick(() => {
          const providerContactSelector = this.$refs
            .providerContactSelector as ProviderContactSelectorType;
          const autocomplete: BAutocompleteType =
            providerContactSelector.$refs.autocomplete;
          const input: HTMLElement = autocomplete.$refs.input.$refs.input;
          input.focus();
        });
      }
    },

    handleSelectorBlur(): void {
      // Hack: Changing state to Displaying will hide the autocomplete input
      // element. However, we need to give it a chance to emit its `select`
      // event, and it does not do this when it is hidden (at least, on MacOS
      // Chrome). So, we delay the state change to give time for the `select`
      // event to fire. I think that it should be possible to effect this delay
      // using $nextTick, but that didn't work in practice. There is some
      // animation in the buefy autocomplete code that may be relevant.
      setTimeout(() => (this.state = State.Displaying), 101);
    },
  },
});
</script>
